package osm;

option go_package = "osmpb";

message Changeset {
  required int64 id = 1;

  // Parallel arrays.
  repeated uint32 keys = 2 [packed = true];
  repeated uint32 vals = 3 [packed = true];

  // contains the tag strings for everything in this changeset.
  repeated string strings = 4;

  optional int32 uid = 5;
  optional uint32 user_sid = 6;
  optional int64 created_at = 7; // epoch time
  optional int64 closed_at = 8; // epoch time

  optional Bounds bounds = 9;
  optional Change change = 10;
}

message Change {
  // not encoded, yet?
  // optional Bounds bounds = 1;

  // contains the tag strings if this is the root of the data.
  repeated string strings = 2;

  optional OSM create = 3;
  optional OSM modify = 4;
  optional OSM delete = 5;
}

message Bounds {
	required sint64 min_lng = 1;
	required sint64 max_lng = 2;
	required sint64 min_lat = 3;
	required sint64 max_lat = 4;
}

message OSM {
  optional Bounds bounds = 1;

  // contains the tag strings if this is the root of the data.
  repeated string strings = 2;

  // an encoded should have either nodes or a dense_nodes, but not both.
  repeated Node       nodes = 3;
  optional DenseNodes dense_nodes = 4;

  repeated Way        ways = 5;
  repeated Relation   relations = 6;
}

// The message defined below are trying to match the official osm pdf
// see http://wiki.openstreetmap.org/wiki/PBF_Format
// and https://github.com/scrosby/OSM-binary/blob/master/src/osmformat.proto

message Node {
  required int64 id = 1;

  // Parallel arrays.
  repeated uint32 keys = 2 [packed = true]; // String IDs.
  repeated uint32 vals = 3 [packed = true]; // String IDs.

  optional Info info = 4;

  required sint64 lat = 8;
  required sint64 lng = 9;
}

message Info {
  optional int32 version = 1;
  optional int64 timestamp = 2; // Epoch

  // these will be omitted if the object represents one changeset
  // since they will be all the same.
  optional int64 changeset = 3;
  optional int32 uid = 4;
  optional uint32 user_sid = 5; // String ID

  // The visible flag is used to store history information. It indicates that
  // the current object version has been created by a delete operation on the
  // OSM API. This info may be omitted if it can be inferred from its group
  // ie. create, modify, delete.
  optional bool visible = 6;
}

message DenseNodes {
  repeated sint64 id = 1 [packed = true]; // DELTA coded

  optional DenseInfo dense_info = 5;

  repeated sint64 lat = 8 [packed = true]; // DELTA coded
  repeated sint64 lng = 9 [packed = true]; // DELTA coded

  // Special packing of keys and vals into one array. We use a single stringid
  // of 0 to delimit when the tags of a node ends and the tags of the next node
  // begin. The storage pattern is: ((<keyid> <valid>)* '0' )* As an exception,
  // if no node in the current block has any key/value pairs, this array does
  // not contain any delimiters, but is simply empty.
  repeated uint32 keys_vals = 10 [packed = true];
}

message DenseInfo {
  repeated int32 version = 1 [packed = true];
  repeated sint64 timestamp = 2 [packed = true]; // DELTA coded

  // these will be omitted if the object represents one changeset
  // and these will be all the same.
  repeated sint64 changeset = 3 [packed = true]; // DELTA coded
  repeated sint32 uid = 4 [packed = true]; // DELTA coded
  repeated int32 user_sid = 5 [packed = true]; // String IDs for usernames. DELTA coded

  // The visible flag is used to store history information. It indicates that
  // the current object version has been created by a delete operation on the
  // OSM API. This info may be omitted if it can be inferred from it's group
  // ie. create, modify, delete.
  repeated bool visible = 6 [packed = true];
}

message Way {
  required int64 id = 1;

  // Parallel arrays.
  repeated uint32 keys = 2 [packed = true];
  repeated uint32 vals = 3 [packed = true];

  optional Info info = 4;

  repeated sint64 refs = 8 [packed = true];  // DELTA coded
}

message Relation {
  enum MemberType {
    NODE = 0;
    WAY = 1;
    RELATION = 2;
  }

  required int64 id = 1;

  // Parallel arrays.
  repeated uint32 keys = 2 [packed = true];
  repeated uint32 vals = 3 [packed = true];

  optional Info info = 4;

  // Parallel arrays
  repeated uint32 roles = 8 [packed = true]; // String IDs.
  repeated sint64 refs = 9 [packed = true]; // DELTA encoded
  repeated MemberType types = 10 [packed = true];
}

