package osmxml

import (
	"context"
	"encoding/xml"
	"io"

	osm "github.com/paulmach/go.osm"
)

var _ osm.Scanner = &Scanner{}

// Scanner provides a convenient interface reading a stream of osm data
// from a file or url. Successive calls to the Scan method will step through the data.
//
// Scanning stops unrecoverably at EOF, the first I/O error, the first xml error or
// the context being cancelled. When a scan stops, the reader may have advanced
// arbitrarily far past the last token.
//
// The Scanner API is based on bufio.Scanner
// https://golang.org/pkg/bufio/#Scanner
type Scanner struct {
	ctx    context.Context
	cancel func()
	closed bool

	decoder *xml.Decoder
	next    osm.Element
	err     error
}

// New returns a new Scanner to read from r.
func New(ctx context.Context, r io.Reader) *Scanner {
	if ctx == nil {
		ctx = context.Background()
	}

	s := &Scanner{
		decoder: xml.NewDecoder(r),
	}

	s.ctx, s.cancel = context.WithCancel(ctx)
	return s
}

// Close causes all future calls to Scan to return false.
// Does not close the underlying reader.
func (s *Scanner) Close() error {
	s.closed = true
	s.cancel()

	return nil
}

// Scan advances the Scanner to the next element, which will then be available
// through the Element method. It returns false when the scan stops, either
// by reaching the end of the input, an io error, an xml error or the context
// being cancelled. After Scan returns false, the Err method will return any
// error that occurred during scanning, except that if it was io.EOF, Err will
// return nil.
func (s *Scanner) Scan() bool {
	if s.err != nil {
		return false
	}

Loop:
	for {
		if s.ctx.Err() != nil {
			return false
		}

		t, err := s.decoder.Token()
		if err != nil {
			s.err = err
			return false
		}

		se, ok := t.(xml.StartElement)
		if !ok {
			continue
		}

		s.next = osm.Element{}
		switch se.Name.Local {
		case "changeset":
			err = s.decoder.DecodeElement(&s.next.Changeset, &se)
		case "node":
			err = s.decoder.DecodeElement(&s.next.Node, &se)
		case "way":
			err = s.decoder.DecodeElement(&s.next.Way, &se)
		case "relation":
			err = s.decoder.DecodeElement(&s.next.Relation, &se)
		default:
			continue Loop
		}

		if err != nil {
			s.err = err
			return false
		}

		return true
	}
}

// Element returns the most recent token generated by a call to Scan
// as a new osm Element.
func (s *Scanner) Element() osm.Element {
	return s.next
}

// Err returns the first non-EOF error that was encountered by the Scanner.
func (s *Scanner) Err() error {
	if s.err == io.EOF {
		return nil
	}

	if s.err != nil {
		return s.err
	}

	if s.closed {
		return osm.ErrScannerClosed
	}

	return s.ctx.Err()
}
