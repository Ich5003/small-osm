// Code generated by protoc-gen-gogo.
// source: osm.proto
// DO NOT EDIT!

/*
	Package osmpb is a generated protocol buffer package.

	It is generated from these files:
		osm.proto

	It has these top-level messages:
		Changeset
		Bounds
		Change
		Tags
		OSM
		Node
		Info
		DenseNodes
		DenseInfo
		Way
		Relation
*/
package osmpb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Relation_MemberType int32

const (
	Relation_NODE     Relation_MemberType = 0
	Relation_WAY      Relation_MemberType = 1
	Relation_RELATION Relation_MemberType = 2
)

var Relation_MemberType_name = map[int32]string{
	0: "NODE",
	1: "WAY",
	2: "RELATION",
}
var Relation_MemberType_value = map[string]int32{
	"NODE":     0,
	"WAY":      1,
	"RELATION": 2,
}

func (x Relation_MemberType) Enum() *Relation_MemberType {
	p := new(Relation_MemberType)
	*p = x
	return p
}
func (x Relation_MemberType) String() string {
	return proto.EnumName(Relation_MemberType_name, int32(x))
}
func (x *Relation_MemberType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Relation_MemberType_value, data, "Relation_MemberType")
	if err != nil {
		return err
	}
	*x = Relation_MemberType(value)
	return nil
}
func (Relation_MemberType) EnumDescriptor() ([]byte, []int) { return fileDescriptorOsm, []int{10, 0} }

type Changeset struct {
	Id *int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// Parallel arrays.
	Keys      []uint32 `protobuf:"varint,2,rep,packed,name=keys" json:"keys,omitempty"`
	Vals      []uint32 `protobuf:"varint,3,rep,packed,name=vals" json:"vals,omitempty"`
	UserId    *int32   `protobuf:"varint,5,opt,name=user_id" json:"user_id,omitempty"`
	UserSid   *uint32  `protobuf:"varint,6,opt,name=user_sid" json:"user_sid,omitempty"`
	CreatedAt *int64   `protobuf:"varint,7,opt,name=created_at" json:"created_at,omitempty"`
	ClosedAt  *int64   `protobuf:"varint,8,opt,name=closed_at" json:"closed_at,omitempty"`
	Open      *bool    `protobuf:"varint,9,opt,name=open" json:"open,omitempty"`
	Bounds    *Bounds  `protobuf:"bytes,10,opt,name=bounds" json:"bounds,omitempty"`
	Change    *Change  `protobuf:"bytes,11,opt,name=change" json:"change,omitempty"`
	// contains the tag strings for everything
	// in this entire changeset.
	Strings []string `protobuf:"bytes,20,rep,name=strings" json:"strings,omitempty"`
}

func (m *Changeset) Reset()                    { *m = Changeset{} }
func (m *Changeset) String() string            { return proto.CompactTextString(m) }
func (*Changeset) ProtoMessage()               {}
func (*Changeset) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{0} }

func (m *Changeset) GetId() int64 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Changeset) GetKeys() []uint32 {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Changeset) GetVals() []uint32 {
	if m != nil {
		return m.Vals
	}
	return nil
}

func (m *Changeset) GetUserId() int32 {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return 0
}

func (m *Changeset) GetUserSid() uint32 {
	if m != nil && m.UserSid != nil {
		return *m.UserSid
	}
	return 0
}

func (m *Changeset) GetCreatedAt() int64 {
	if m != nil && m.CreatedAt != nil {
		return *m.CreatedAt
	}
	return 0
}

func (m *Changeset) GetClosedAt() int64 {
	if m != nil && m.ClosedAt != nil {
		return *m.ClosedAt
	}
	return 0
}

func (m *Changeset) GetOpen() bool {
	if m != nil && m.Open != nil {
		return *m.Open
	}
	return false
}

func (m *Changeset) GetBounds() *Bounds {
	if m != nil {
		return m.Bounds
	}
	return nil
}

func (m *Changeset) GetChange() *Change {
	if m != nil {
		return m.Change
	}
	return nil
}

func (m *Changeset) GetStrings() []string {
	if m != nil {
		return m.Strings
	}
	return nil
}

type Bounds struct {
	MinLon int64 `protobuf:"zigzag64,1,req,name=min_lon" json:"min_lon"`
	MaxLon int64 `protobuf:"zigzag64,2,req,name=max_lon" json:"max_lon"`
	MinLat int64 `protobuf:"zigzag64,3,req,name=min_lat" json:"min_lat"`
	MaxLat int64 `protobuf:"zigzag64,4,req,name=max_lat" json:"max_lat"`
}

func (m *Bounds) Reset()                    { *m = Bounds{} }
func (m *Bounds) String() string            { return proto.CompactTextString(m) }
func (*Bounds) ProtoMessage()               {}
func (*Bounds) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{1} }

func (m *Bounds) GetMinLon() int64 {
	if m != nil {
		return m.MinLon
	}
	return 0
}

func (m *Bounds) GetMaxLon() int64 {
	if m != nil {
		return m.MaxLon
	}
	return 0
}

func (m *Bounds) GetMinLat() int64 {
	if m != nil {
		return m.MinLat
	}
	return 0
}

func (m *Bounds) GetMaxLat() int64 {
	if m != nil {
		return m.MaxLat
	}
	return 0
}

type Change struct {
	Create *OSM `protobuf:"bytes,1,opt,name=create" json:"create,omitempty"`
	Modify *OSM `protobuf:"bytes,2,opt,name=modify" json:"modify,omitempty"`
	Delete *OSM `protobuf:"bytes,3,opt,name=delete" json:"delete,omitempty"`
	// elements that give the change extra context like
	// nodes of the ways, and previous versions.
	Context *OSM `protobuf:"bytes,4,opt,name=context" json:"context,omitempty"`
	// contains the tag strings if this is the root of the data.
	Strings []string `protobuf:"bytes,20,rep,name=strings" json:"strings,omitempty"`
}

func (m *Change) Reset()                    { *m = Change{} }
func (m *Change) String() string            { return proto.CompactTextString(m) }
func (*Change) ProtoMessage()               {}
func (*Change) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{2} }

func (m *Change) GetCreate() *OSM {
	if m != nil {
		return m.Create
	}
	return nil
}

func (m *Change) GetModify() *OSM {
	if m != nil {
		return m.Modify
	}
	return nil
}

func (m *Change) GetDelete() *OSM {
	if m != nil {
		return m.Delete
	}
	return nil
}

func (m *Change) GetContext() *OSM {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *Change) GetStrings() []string {
	if m != nil {
		return m.Strings
	}
	return nil
}

type Tags struct {
	// encoded as [key1, val1, key2, val2, etc.]
	KeysVals []string `protobuf:"bytes,1,rep,name=keys_vals" json:"keys_vals,omitempty"`
}

func (m *Tags) Reset()                    { *m = Tags{} }
func (m *Tags) String() string            { return proto.CompactTextString(m) }
func (*Tags) ProtoMessage()               {}
func (*Tags) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{3} }

func (m *Tags) GetKeysVals() []string {
	if m != nil {
		return m.KeysVals
	}
	return nil
}

type OSM struct {
	Bounds *Bounds `protobuf:"bytes,1,opt,name=bounds" json:"bounds,omitempty"`
	// an encoded should have either nodes or a dense_nodes, but not both.
	Nodes      []*Node     `protobuf:"bytes,2,rep,name=nodes" json:"nodes,omitempty"`
	DenseNodes *DenseNodes `protobuf:"bytes,3,opt,name=dense_nodes" json:"dense_nodes,omitempty"`
	Ways       []*Way      `protobuf:"bytes,4,rep,name=ways" json:"ways,omitempty"`
	Relations  []*Relation `protobuf:"bytes,5,rep,name=relations" json:"relations,omitempty"`
	// contains the tag strings if this is the root of the data.
	Strings []string `protobuf:"bytes,15,rep,name=strings" json:"strings,omitempty"`
}

func (m *OSM) Reset()                    { *m = OSM{} }
func (m *OSM) String() string            { return proto.CompactTextString(m) }
func (*OSM) ProtoMessage()               {}
func (*OSM) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{4} }

func (m *OSM) GetBounds() *Bounds {
	if m != nil {
		return m.Bounds
	}
	return nil
}

func (m *OSM) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *OSM) GetDenseNodes() *DenseNodes {
	if m != nil {
		return m.DenseNodes
	}
	return nil
}

func (m *OSM) GetWays() []*Way {
	if m != nil {
		return m.Ways
	}
	return nil
}

func (m *OSM) GetRelations() []*Relation {
	if m != nil {
		return m.Relations
	}
	return nil
}

func (m *OSM) GetStrings() []string {
	if m != nil {
		return m.Strings
	}
	return nil
}

type Node struct {
	Id int64 `protobuf:"varint,1,req,name=id" json:"id"`
	// Parallel arrays.
	Keys []uint32 `protobuf:"varint,2,rep,packed,name=keys" json:"keys,omitempty"`
	Vals []uint32 `protobuf:"varint,3,rep,packed,name=vals" json:"vals,omitempty"`
	Info *Info    `protobuf:"bytes,4,opt,name=info" json:"info,omitempty"`
	Lat  int64    `protobuf:"zigzag64,8,req,name=lat" json:"lat"`
	Lon  int64    `protobuf:"zigzag64,9,req,name=lon" json:"lon"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{5} }

func (m *Node) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Node) GetKeys() []uint32 {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Node) GetVals() []uint32 {
	if m != nil {
		return m.Vals
	}
	return nil
}

func (m *Node) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Node) GetLat() int64 {
	if m != nil {
		return m.Lat
	}
	return 0
}

func (m *Node) GetLon() int64 {
	if m != nil {
		return m.Lon
	}
	return 0
}

type Info struct {
	Version   int32 `protobuf:"varint,1,opt,name=version" json:"version"`
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp" json:"timestamp"`
	// these caan be omitted if the object represents one changeset
	// since they will be all the same. However tests on 200k changesets
	// show this saves about 17 bytes per changeset on average after gzip.
	ChangesetId int64  `protobuf:"varint,3,opt,name=changeset_id" json:"changeset_id"`
	UserId      int32  `protobuf:"varint,4,opt,name=user_id" json:"user_id"`
	UserSid     uint32 `protobuf:"varint,5,opt,name=user_sid" json:"user_sid"`
	// The visible flag is used to store history information. It indicates that
	// the current object version has been created by a delete operation on the
	// OSM API. This info may be omitted if it can be inferred from its group
	// ie. create, modify, delete.
	Visible *bool `protobuf:"varint,6,opt,name=visible" json:"visible,omitempty"`
}

func (m *Info) Reset()                    { *m = Info{} }
func (m *Info) String() string            { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()               {}
func (*Info) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{6} }

func (m *Info) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Info) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Info) GetChangesetId() int64 {
	if m != nil {
		return m.ChangesetId
	}
	return 0
}

func (m *Info) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Info) GetUserSid() uint32 {
	if m != nil {
		return m.UserSid
	}
	return 0
}

func (m *Info) GetVisible() bool {
	if m != nil && m.Visible != nil {
		return *m.Visible
	}
	return false
}

type DenseNodes struct {
	Id        []int64    `protobuf:"zigzag64,1,rep,packed,name=id" json:"id,omitempty"`
	DenseInfo *DenseInfo `protobuf:"bytes,5,opt,name=dense_info" json:"dense_info,omitempty"`
	Lat       []int64    `protobuf:"zigzag64,8,rep,packed,name=lat" json:"lat,omitempty"`
	Lon       []int64    `protobuf:"zigzag64,9,rep,packed,name=lon" json:"lon,omitempty"`
	// Special packing of keys and vals into one array. We use a single stringid
	// of 0 to delimit when the tags of a node ends and the tags of the next node
	// begin. The storage pattern is: ((<keyid> <valid>)* '0' )* As an exception,
	// if no node in the current block has any key/value pairs, this array does
	// not contain any delimiters, but is simply empty.
	KeysVals []uint32 `protobuf:"varint,10,rep,packed,name=keys_vals" json:"keys_vals,omitempty"`
	Strings  []string `protobuf:"bytes,15,rep,name=strings" json:"strings,omitempty"`
}

func (m *DenseNodes) Reset()                    { *m = DenseNodes{} }
func (m *DenseNodes) String() string            { return proto.CompactTextString(m) }
func (*DenseNodes) ProtoMessage()               {}
func (*DenseNodes) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{7} }

func (m *DenseNodes) GetId() []int64 {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *DenseNodes) GetDenseInfo() *DenseInfo {
	if m != nil {
		return m.DenseInfo
	}
	return nil
}

func (m *DenseNodes) GetLat() []int64 {
	if m != nil {
		return m.Lat
	}
	return nil
}

func (m *DenseNodes) GetLon() []int64 {
	if m != nil {
		return m.Lon
	}
	return nil
}

func (m *DenseNodes) GetKeysVals() []uint32 {
	if m != nil {
		return m.KeysVals
	}
	return nil
}

func (m *DenseNodes) GetStrings() []string {
	if m != nil {
		return m.Strings
	}
	return nil
}

type DenseInfo struct {
	Version   []int32 `protobuf:"varint,1,rep,packed,name=version" json:"version,omitempty"`
	Timestamp []int64 `protobuf:"zigzag64,2,rep,packed,name=timestamp" json:"timestamp,omitempty"`
	// these will be omitted if the object represents one changeset
	// and these will be all the same.
	ChangesetId []int64 `protobuf:"zigzag64,3,rep,packed,name=changeset_id" json:"changeset_id,omitempty"`
	UserId      []int32 `protobuf:"zigzag32,4,rep,packed,name=user_id" json:"user_id,omitempty"`
	UserSid     []int32 `protobuf:"zigzag32,5,rep,packed,name=user_sid" json:"user_sid,omitempty"`
	// The visible flag is used to store history information. It indicates that
	// the current object version has been created by a delete operation on the
	// OSM API. This info may be omitted if it can be inferred from it's group
	// ie. create, modify, delete.
	Visible []bool `protobuf:"varint,6,rep,packed,name=visible" json:"visible,omitempty"`
}

func (m *DenseInfo) Reset()                    { *m = DenseInfo{} }
func (m *DenseInfo) String() string            { return proto.CompactTextString(m) }
func (*DenseInfo) ProtoMessage()               {}
func (*DenseInfo) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{8} }

func (m *DenseInfo) GetVersion() []int32 {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *DenseInfo) GetTimestamp() []int64 {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *DenseInfo) GetChangesetId() []int64 {
	if m != nil {
		return m.ChangesetId
	}
	return nil
}

func (m *DenseInfo) GetUserId() []int32 {
	if m != nil {
		return m.UserId
	}
	return nil
}

func (m *DenseInfo) GetUserSid() []int32 {
	if m != nil {
		return m.UserSid
	}
	return nil
}

func (m *DenseInfo) GetVisible() []bool {
	if m != nil {
		return m.Visible
	}
	return nil
}

type Way struct {
	Id int64 `protobuf:"varint,1,req,name=id" json:"id"`
	// Parallel arrays.
	Keys []uint32 `protobuf:"varint,2,rep,packed,name=keys" json:"keys,omitempty"`
	Vals []uint32 `protobuf:"varint,3,rep,packed,name=vals" json:"vals,omitempty"`
	Info *Info    `protobuf:"bytes,4,opt,name=info" json:"info,omitempty"`
	Refs []int64  `protobuf:"zigzag64,8,rep,packed,name=refs" json:"refs,omitempty"`
}

func (m *Way) Reset()                    { *m = Way{} }
func (m *Way) String() string            { return proto.CompactTextString(m) }
func (*Way) ProtoMessage()               {}
func (*Way) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{9} }

func (m *Way) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Way) GetKeys() []uint32 {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Way) GetVals() []uint32 {
	if m != nil {
		return m.Vals
	}
	return nil
}

func (m *Way) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Way) GetRefs() []int64 {
	if m != nil {
		return m.Refs
	}
	return nil
}

type Relation struct {
	Id int64 `protobuf:"varint,1,req,name=id" json:"id"`
	// Parallel arrays.
	Keys []uint32 `protobuf:"varint,2,rep,packed,name=keys" json:"keys,omitempty"`
	Vals []uint32 `protobuf:"varint,3,rep,packed,name=vals" json:"vals,omitempty"`
	Info *Info    `protobuf:"bytes,4,opt,name=info" json:"info,omitempty"`
	// Parallel arrays
	// Roles has been changed int32 -> uint32 form the osm proto,
	// this is for consistency and backwards compatible.
	Roles []uint32              `protobuf:"varint,8,rep,packed,name=roles" json:"roles,omitempty"`
	Refs  []int64               `protobuf:"zigzag64,9,rep,packed,name=refs" json:"refs,omitempty"`
	Types []Relation_MemberType `protobuf:"varint,10,rep,packed,name=types,enum=osm.Relation_MemberType" json:"types,omitempty"`
}

func (m *Relation) Reset()                    { *m = Relation{} }
func (m *Relation) String() string            { return proto.CompactTextString(m) }
func (*Relation) ProtoMessage()               {}
func (*Relation) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{10} }

func (m *Relation) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Relation) GetKeys() []uint32 {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Relation) GetVals() []uint32 {
	if m != nil {
		return m.Vals
	}
	return nil
}

func (m *Relation) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Relation) GetRoles() []uint32 {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *Relation) GetRefs() []int64 {
	if m != nil {
		return m.Refs
	}
	return nil
}

func (m *Relation) GetTypes() []Relation_MemberType {
	if m != nil {
		return m.Types
	}
	return nil
}

func init() {
	proto.RegisterType((*Changeset)(nil), "osm.Changeset")
	proto.RegisterType((*Bounds)(nil), "osm.Bounds")
	proto.RegisterType((*Change)(nil), "osm.Change")
	proto.RegisterType((*Tags)(nil), "osm.Tags")
	proto.RegisterType((*OSM)(nil), "osm.OSM")
	proto.RegisterType((*Node)(nil), "osm.Node")
	proto.RegisterType((*Info)(nil), "osm.Info")
	proto.RegisterType((*DenseNodes)(nil), "osm.DenseNodes")
	proto.RegisterType((*DenseInfo)(nil), "osm.DenseInfo")
	proto.RegisterType((*Way)(nil), "osm.Way")
	proto.RegisterType((*Relation)(nil), "osm.Relation")
	proto.RegisterEnum("osm.Relation_MemberType", Relation_MemberType_name, Relation_MemberType_value)
}
func (m *Changeset) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Changeset) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		data[i] = 0x8
		i++
		i = encodeVarintOsm(data, i, uint64(*m.Id))
	}
	if len(m.Keys) > 0 {
		data2 := make([]byte, len(m.Keys)*10)
		var j1 int
		for _, num := range m.Keys {
			for num >= 1<<7 {
				data2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			data2[j1] = uint8(num)
			j1++
		}
		data[i] = 0x12
		i++
		i = encodeVarintOsm(data, i, uint64(j1))
		i += copy(data[i:], data2[:j1])
	}
	if len(m.Vals) > 0 {
		data4 := make([]byte, len(m.Vals)*10)
		var j3 int
		for _, num := range m.Vals {
			for num >= 1<<7 {
				data4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			data4[j3] = uint8(num)
			j3++
		}
		data[i] = 0x1a
		i++
		i = encodeVarintOsm(data, i, uint64(j3))
		i += copy(data[i:], data4[:j3])
	}
	if m.UserId != nil {
		data[i] = 0x28
		i++
		i = encodeVarintOsm(data, i, uint64(*m.UserId))
	}
	if m.UserSid != nil {
		data[i] = 0x30
		i++
		i = encodeVarintOsm(data, i, uint64(*m.UserSid))
	}
	if m.CreatedAt != nil {
		data[i] = 0x38
		i++
		i = encodeVarintOsm(data, i, uint64(*m.CreatedAt))
	}
	if m.ClosedAt != nil {
		data[i] = 0x40
		i++
		i = encodeVarintOsm(data, i, uint64(*m.ClosedAt))
	}
	if m.Open != nil {
		data[i] = 0x48
		i++
		if *m.Open {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Bounds != nil {
		data[i] = 0x52
		i++
		i = encodeVarintOsm(data, i, uint64(m.Bounds.Size()))
		n5, err := m.Bounds.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Change != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintOsm(data, i, uint64(m.Change.Size()))
		n6, err := m.Change.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			data[i] = 0xa2
			i++
			data[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *Bounds) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Bounds) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintOsm(data, i, uint64((uint64(m.MinLon)<<1)^uint64((m.MinLon>>63))))
	data[i] = 0x10
	i++
	i = encodeVarintOsm(data, i, uint64((uint64(m.MaxLon)<<1)^uint64((m.MaxLon>>63))))
	data[i] = 0x18
	i++
	i = encodeVarintOsm(data, i, uint64((uint64(m.MinLat)<<1)^uint64((m.MinLat>>63))))
	data[i] = 0x20
	i++
	i = encodeVarintOsm(data, i, uint64((uint64(m.MaxLat)<<1)^uint64((m.MaxLat>>63))))
	return i, nil
}

func (m *Change) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Change) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Create != nil {
		data[i] = 0xa
		i++
		i = encodeVarintOsm(data, i, uint64(m.Create.Size()))
		n7, err := m.Create.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Modify != nil {
		data[i] = 0x12
		i++
		i = encodeVarintOsm(data, i, uint64(m.Modify.Size()))
		n8, err := m.Modify.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Delete != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintOsm(data, i, uint64(m.Delete.Size()))
		n9, err := m.Delete.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Context != nil {
		data[i] = 0x22
		i++
		i = encodeVarintOsm(data, i, uint64(m.Context.Size()))
		n10, err := m.Context.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			data[i] = 0xa2
			i++
			data[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *Tags) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Tags) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.KeysVals) > 0 {
		for _, s := range m.KeysVals {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *OSM) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OSM) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bounds != nil {
		data[i] = 0xa
		i++
		i = encodeVarintOsm(data, i, uint64(m.Bounds.Size()))
		n11, err := m.Bounds.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			data[i] = 0x12
			i++
			i = encodeVarintOsm(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DenseNodes != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintOsm(data, i, uint64(m.DenseNodes.Size()))
		n12, err := m.DenseNodes.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Ways) > 0 {
		for _, msg := range m.Ways {
			data[i] = 0x22
			i++
			i = encodeVarintOsm(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Relations) > 0 {
		for _, msg := range m.Relations {
			data[i] = 0x2a
			i++
			i = encodeVarintOsm(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			data[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *Node) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Node) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintOsm(data, i, uint64(m.Id))
	if len(m.Keys) > 0 {
		data14 := make([]byte, len(m.Keys)*10)
		var j13 int
		for _, num := range m.Keys {
			for num >= 1<<7 {
				data14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			data14[j13] = uint8(num)
			j13++
		}
		data[i] = 0x12
		i++
		i = encodeVarintOsm(data, i, uint64(j13))
		i += copy(data[i:], data14[:j13])
	}
	if len(m.Vals) > 0 {
		data16 := make([]byte, len(m.Vals)*10)
		var j15 int
		for _, num := range m.Vals {
			for num >= 1<<7 {
				data16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			data16[j15] = uint8(num)
			j15++
		}
		data[i] = 0x1a
		i++
		i = encodeVarintOsm(data, i, uint64(j15))
		i += copy(data[i:], data16[:j15])
	}
	if m.Info != nil {
		data[i] = 0x22
		i++
		i = encodeVarintOsm(data, i, uint64(m.Info.Size()))
		n17, err := m.Info.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	data[i] = 0x40
	i++
	i = encodeVarintOsm(data, i, uint64((uint64(m.Lat)<<1)^uint64((m.Lat>>63))))
	data[i] = 0x48
	i++
	i = encodeVarintOsm(data, i, uint64((uint64(m.Lon)<<1)^uint64((m.Lon>>63))))
	return i, nil
}

func (m *Info) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Info) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintOsm(data, i, uint64(m.Version))
	data[i] = 0x10
	i++
	i = encodeVarintOsm(data, i, uint64(m.Timestamp))
	data[i] = 0x18
	i++
	i = encodeVarintOsm(data, i, uint64(m.ChangesetId))
	data[i] = 0x20
	i++
	i = encodeVarintOsm(data, i, uint64(m.UserId))
	data[i] = 0x28
	i++
	i = encodeVarintOsm(data, i, uint64(m.UserSid))
	if m.Visible != nil {
		data[i] = 0x30
		i++
		if *m.Visible {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DenseNodes) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DenseNodes) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		var j18 int
		data20 := make([]byte, len(m.Id)*10)
		for _, num := range m.Id {
			x19 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x19 >= 1<<7 {
				data20[j18] = uint8(uint64(x19)&0x7f | 0x80)
				j18++
				x19 >>= 7
			}
			data20[j18] = uint8(x19)
			j18++
		}
		data[i] = 0xa
		i++
		i = encodeVarintOsm(data, i, uint64(j18))
		i += copy(data[i:], data20[:j18])
	}
	if m.DenseInfo != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintOsm(data, i, uint64(m.DenseInfo.Size()))
		n21, err := m.DenseInfo.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.Lat) > 0 {
		var j22 int
		data24 := make([]byte, len(m.Lat)*10)
		for _, num := range m.Lat {
			x23 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x23 >= 1<<7 {
				data24[j22] = uint8(uint64(x23)&0x7f | 0x80)
				j22++
				x23 >>= 7
			}
			data24[j22] = uint8(x23)
			j22++
		}
		data[i] = 0x42
		i++
		i = encodeVarintOsm(data, i, uint64(j22))
		i += copy(data[i:], data24[:j22])
	}
	if len(m.Lon) > 0 {
		var j25 int
		data27 := make([]byte, len(m.Lon)*10)
		for _, num := range m.Lon {
			x26 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x26 >= 1<<7 {
				data27[j25] = uint8(uint64(x26)&0x7f | 0x80)
				j25++
				x26 >>= 7
			}
			data27[j25] = uint8(x26)
			j25++
		}
		data[i] = 0x4a
		i++
		i = encodeVarintOsm(data, i, uint64(j25))
		i += copy(data[i:], data27[:j25])
	}
	if len(m.KeysVals) > 0 {
		data29 := make([]byte, len(m.KeysVals)*10)
		var j28 int
		for _, num := range m.KeysVals {
			for num >= 1<<7 {
				data29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			data29[j28] = uint8(num)
			j28++
		}
		data[i] = 0x52
		i++
		i = encodeVarintOsm(data, i, uint64(j28))
		i += copy(data[i:], data29[:j28])
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			data[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *DenseInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DenseInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		data31 := make([]byte, len(m.Version)*10)
		var j30 int
		for _, num1 := range m.Version {
			num := uint64(num1)
			for num >= 1<<7 {
				data31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			data31[j30] = uint8(num)
			j30++
		}
		data[i] = 0xa
		i++
		i = encodeVarintOsm(data, i, uint64(j30))
		i += copy(data[i:], data31[:j30])
	}
	if len(m.Timestamp) > 0 {
		var j32 int
		data34 := make([]byte, len(m.Timestamp)*10)
		for _, num := range m.Timestamp {
			x33 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x33 >= 1<<7 {
				data34[j32] = uint8(uint64(x33)&0x7f | 0x80)
				j32++
				x33 >>= 7
			}
			data34[j32] = uint8(x33)
			j32++
		}
		data[i] = 0x12
		i++
		i = encodeVarintOsm(data, i, uint64(j32))
		i += copy(data[i:], data34[:j32])
	}
	if len(m.ChangesetId) > 0 {
		var j35 int
		data37 := make([]byte, len(m.ChangesetId)*10)
		for _, num := range m.ChangesetId {
			x36 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x36 >= 1<<7 {
				data37[j35] = uint8(uint64(x36)&0x7f | 0x80)
				j35++
				x36 >>= 7
			}
			data37[j35] = uint8(x36)
			j35++
		}
		data[i] = 0x1a
		i++
		i = encodeVarintOsm(data, i, uint64(j35))
		i += copy(data[i:], data37[:j35])
	}
	if len(m.UserId) > 0 {
		data38 := make([]byte, len(m.UserId)*5)
		var j39 int
		for _, num := range m.UserId {
			x40 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x40 >= 1<<7 {
				data38[j39] = uint8(uint64(x40)&0x7f | 0x80)
				j39++
				x40 >>= 7
			}
			data38[j39] = uint8(x40)
			j39++
		}
		data[i] = 0x22
		i++
		i = encodeVarintOsm(data, i, uint64(j39))
		i += copy(data[i:], data38[:j39])
	}
	if len(m.UserSid) > 0 {
		data41 := make([]byte, len(m.UserSid)*5)
		var j42 int
		for _, num := range m.UserSid {
			x43 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x43 >= 1<<7 {
				data41[j42] = uint8(uint64(x43)&0x7f | 0x80)
				j42++
				x43 >>= 7
			}
			data41[j42] = uint8(x43)
			j42++
		}
		data[i] = 0x2a
		i++
		i = encodeVarintOsm(data, i, uint64(j42))
		i += copy(data[i:], data41[:j42])
	}
	if len(m.Visible) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintOsm(data, i, uint64(len(m.Visible)))
		for _, b := range m.Visible {
			if b {
				data[i] = 1
			} else {
				data[i] = 0
			}
			i++
		}
	}
	return i, nil
}

func (m *Way) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Way) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintOsm(data, i, uint64(m.Id))
	if len(m.Keys) > 0 {
		data45 := make([]byte, len(m.Keys)*10)
		var j44 int
		for _, num := range m.Keys {
			for num >= 1<<7 {
				data45[j44] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j44++
			}
			data45[j44] = uint8(num)
			j44++
		}
		data[i] = 0x12
		i++
		i = encodeVarintOsm(data, i, uint64(j44))
		i += copy(data[i:], data45[:j44])
	}
	if len(m.Vals) > 0 {
		data47 := make([]byte, len(m.Vals)*10)
		var j46 int
		for _, num := range m.Vals {
			for num >= 1<<7 {
				data47[j46] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j46++
			}
			data47[j46] = uint8(num)
			j46++
		}
		data[i] = 0x1a
		i++
		i = encodeVarintOsm(data, i, uint64(j46))
		i += copy(data[i:], data47[:j46])
	}
	if m.Info != nil {
		data[i] = 0x22
		i++
		i = encodeVarintOsm(data, i, uint64(m.Info.Size()))
		n48, err := m.Info.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if len(m.Refs) > 0 {
		var j49 int
		data51 := make([]byte, len(m.Refs)*10)
		for _, num := range m.Refs {
			x50 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x50 >= 1<<7 {
				data51[j49] = uint8(uint64(x50)&0x7f | 0x80)
				j49++
				x50 >>= 7
			}
			data51[j49] = uint8(x50)
			j49++
		}
		data[i] = 0x42
		i++
		i = encodeVarintOsm(data, i, uint64(j49))
		i += copy(data[i:], data51[:j49])
	}
	return i, nil
}

func (m *Relation) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Relation) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintOsm(data, i, uint64(m.Id))
	if len(m.Keys) > 0 {
		data53 := make([]byte, len(m.Keys)*10)
		var j52 int
		for _, num := range m.Keys {
			for num >= 1<<7 {
				data53[j52] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j52++
			}
			data53[j52] = uint8(num)
			j52++
		}
		data[i] = 0x12
		i++
		i = encodeVarintOsm(data, i, uint64(j52))
		i += copy(data[i:], data53[:j52])
	}
	if len(m.Vals) > 0 {
		data55 := make([]byte, len(m.Vals)*10)
		var j54 int
		for _, num := range m.Vals {
			for num >= 1<<7 {
				data55[j54] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j54++
			}
			data55[j54] = uint8(num)
			j54++
		}
		data[i] = 0x1a
		i++
		i = encodeVarintOsm(data, i, uint64(j54))
		i += copy(data[i:], data55[:j54])
	}
	if m.Info != nil {
		data[i] = 0x22
		i++
		i = encodeVarintOsm(data, i, uint64(m.Info.Size()))
		n56, err := m.Info.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if len(m.Roles) > 0 {
		data58 := make([]byte, len(m.Roles)*10)
		var j57 int
		for _, num := range m.Roles {
			for num >= 1<<7 {
				data58[j57] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j57++
			}
			data58[j57] = uint8(num)
			j57++
		}
		data[i] = 0x42
		i++
		i = encodeVarintOsm(data, i, uint64(j57))
		i += copy(data[i:], data58[:j57])
	}
	if len(m.Refs) > 0 {
		var j59 int
		data61 := make([]byte, len(m.Refs)*10)
		for _, num := range m.Refs {
			x60 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x60 >= 1<<7 {
				data61[j59] = uint8(uint64(x60)&0x7f | 0x80)
				j59++
				x60 >>= 7
			}
			data61[j59] = uint8(x60)
			j59++
		}
		data[i] = 0x4a
		i++
		i = encodeVarintOsm(data, i, uint64(j59))
		i += copy(data[i:], data61[:j59])
	}
	if len(m.Types) > 0 {
		data63 := make([]byte, len(m.Types)*10)
		var j62 int
		for _, num := range m.Types {
			for num >= 1<<7 {
				data63[j62] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j62++
			}
			data63[j62] = uint8(num)
			j62++
		}
		data[i] = 0x52
		i++
		i = encodeVarintOsm(data, i, uint64(j62))
		i += copy(data[i:], data63[:j62])
	}
	return i, nil
}

func encodeFixed64Osm(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Osm(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintOsm(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Changeset) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sovOsm(uint64(*m.Id))
	}
	if len(m.Keys) > 0 {
		l = 0
		for _, e := range m.Keys {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Vals) > 0 {
		l = 0
		for _, e := range m.Vals {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.UserId != nil {
		n += 1 + sovOsm(uint64(*m.UserId))
	}
	if m.UserSid != nil {
		n += 1 + sovOsm(uint64(*m.UserSid))
	}
	if m.CreatedAt != nil {
		n += 1 + sovOsm(uint64(*m.CreatedAt))
	}
	if m.ClosedAt != nil {
		n += 1 + sovOsm(uint64(*m.ClosedAt))
	}
	if m.Open != nil {
		n += 2
	}
	if m.Bounds != nil {
		l = m.Bounds.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if m.Change != nil {
		l = m.Change.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			l = len(s)
			n += 2 + l + sovOsm(uint64(l))
		}
	}
	return n
}

func (m *Bounds) Size() (n int) {
	var l int
	_ = l
	n += 1 + sozOsm(uint64(m.MinLon))
	n += 1 + sozOsm(uint64(m.MaxLon))
	n += 1 + sozOsm(uint64(m.MinLat))
	n += 1 + sozOsm(uint64(m.MaxLat))
	return n
}

func (m *Change) Size() (n int) {
	var l int
	_ = l
	if m.Create != nil {
		l = m.Create.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if m.Modify != nil {
		l = m.Modify.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if m.Delete != nil {
		l = m.Delete.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			l = len(s)
			n += 2 + l + sovOsm(uint64(l))
		}
	}
	return n
}

func (m *Tags) Size() (n int) {
	var l int
	_ = l
	if len(m.KeysVals) > 0 {
		for _, s := range m.KeysVals {
			l = len(s)
			n += 1 + l + sovOsm(uint64(l))
		}
	}
	return n
}

func (m *OSM) Size() (n int) {
	var l int
	_ = l
	if m.Bounds != nil {
		l = m.Bounds.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovOsm(uint64(l))
		}
	}
	if m.DenseNodes != nil {
		l = m.DenseNodes.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Ways) > 0 {
		for _, e := range m.Ways {
			l = e.Size()
			n += 1 + l + sovOsm(uint64(l))
		}
	}
	if len(m.Relations) > 0 {
		for _, e := range m.Relations {
			l = e.Size()
			n += 1 + l + sovOsm(uint64(l))
		}
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			l = len(s)
			n += 1 + l + sovOsm(uint64(l))
		}
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovOsm(uint64(m.Id))
	if len(m.Keys) > 0 {
		l = 0
		for _, e := range m.Keys {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Vals) > 0 {
		l = 0
		for _, e := range m.Vals {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	n += 1 + sozOsm(uint64(m.Lat))
	n += 1 + sozOsm(uint64(m.Lon))
	return n
}

func (m *Info) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovOsm(uint64(m.Version))
	n += 1 + sovOsm(uint64(m.Timestamp))
	n += 1 + sovOsm(uint64(m.ChangesetId))
	n += 1 + sovOsm(uint64(m.UserId))
	n += 1 + sovOsm(uint64(m.UserSid))
	if m.Visible != nil {
		n += 2
	}
	return n
}

func (m *DenseNodes) Size() (n int) {
	var l int
	_ = l
	if len(m.Id) > 0 {
		l = 0
		for _, e := range m.Id {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.DenseInfo != nil {
		l = m.DenseInfo.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Lat) > 0 {
		l = 0
		for _, e := range m.Lat {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Lon) > 0 {
		l = 0
		for _, e := range m.Lon {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.KeysVals) > 0 {
		l = 0
		for _, e := range m.KeysVals {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			l = len(s)
			n += 1 + l + sovOsm(uint64(l))
		}
	}
	return n
}

func (m *DenseInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Version) > 0 {
		l = 0
		for _, e := range m.Version {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Timestamp) > 0 {
		l = 0
		for _, e := range m.Timestamp {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.ChangesetId) > 0 {
		l = 0
		for _, e := range m.ChangesetId {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.UserId) > 0 {
		l = 0
		for _, e := range m.UserId {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.UserSid) > 0 {
		l = 0
		for _, e := range m.UserSid {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Visible) > 0 {
		n += 1 + sovOsm(uint64(len(m.Visible))) + len(m.Visible)*1
	}
	return n
}

func (m *Way) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovOsm(uint64(m.Id))
	if len(m.Keys) > 0 {
		l = 0
		for _, e := range m.Keys {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Vals) > 0 {
		l = 0
		for _, e := range m.Vals {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Refs) > 0 {
		l = 0
		for _, e := range m.Refs {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	return n
}

func (m *Relation) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovOsm(uint64(m.Id))
	if len(m.Keys) > 0 {
		l = 0
		for _, e := range m.Keys {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Vals) > 0 {
		l = 0
		for _, e := range m.Vals {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Roles) > 0 {
		l = 0
		for _, e := range m.Roles {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Refs) > 0 {
		l = 0
		for _, e := range m.Refs {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Types) > 0 {
		l = 0
		for _, e := range m.Types {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	return n
}

func sovOsm(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOsm(x uint64) (n int) {
	return sovOsm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Changeset) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Changeset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Changeset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Id = &v
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Keys = append(m.Keys, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Keys = append(m.Keys, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
		case 3:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vals = append(m.Vals, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vals = append(m.Vals, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vals", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UserId = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserSid", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UserSid = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreatedAt = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedAt", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClosedAt = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Open = &b
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bounds == nil {
				m.Bounds = &Bounds{}
			}
			if err := m.Bounds.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Change == nil {
				m.Change = &Change{}
			}
			if err := m.Change.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bounds) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bounds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bounds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLon", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.MinLon = int64(v)
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLon", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.MaxLon = int64(v)
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLat", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.MinLat = int64(v)
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLat", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.MaxLat = int64(v)
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("min_lon")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("max_lon")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("min_lat")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("max_lat")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Change) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Change: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Change: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Create", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Create == nil {
				m.Create = &OSM{}
			}
			if err := m.Create.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modify", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Modify == nil {
				m.Modify = &OSM{}
			}
			if err := m.Modify.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delete == nil {
				m.Delete = &OSM{}
			}
			if err := m.Delete.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &OSM{}
			}
			if err := m.Context.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tags) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysVals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeysVals = append(m.KeysVals, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSM) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSM: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSM: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bounds == nil {
				m.Bounds = &Bounds{}
			}
			if err := m.Bounds.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenseNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenseNodes == nil {
				m.DenseNodes = &DenseNodes{}
			}
			if err := m.DenseNodes.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ways", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ways = append(m.Ways, &Way{})
			if err := m.Ways[len(m.Ways)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relations = append(m.Relations, &Relation{})
			if err := m.Relations[len(m.Relations)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Keys = append(m.Keys, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Keys = append(m.Keys, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
		case 3:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vals = append(m.Vals, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vals = append(m.Vals, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vals", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &Info{}
			}
			if err := m.Info.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Lat = int64(v)
			hasFields[0] |= uint64(0x00000002)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lon", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Lon = int64(v)
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("lat")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("lon")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Info) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangesetId", wireType)
			}
			m.ChangesetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChangesetId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserSid", wireType)
			}
			m.UserSid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UserSid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Visible = &b
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenseNodes) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenseNodes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenseNodes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Id = append(m.Id, int64(v))
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Id = append(m.Id, int64(v))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenseInfo == nil {
				m.DenseInfo = &DenseInfo{}
			}
			if err := m.DenseInfo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Lat = append(m.Lat, int64(v))
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Lat = append(m.Lat, int64(v))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
		case 9:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Lon = append(m.Lon, int64(v))
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Lon = append(m.Lon, int64(v))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Lon", wireType)
			}
		case 10:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeysVals = append(m.KeysVals, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeysVals = append(m.KeysVals, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysVals", wireType)
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenseInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Version = append(m.Version, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Version = append(m.Version, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Timestamp = append(m.Timestamp, int64(v))
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Timestamp = append(m.Timestamp, int64(v))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
		case 3:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.ChangesetId = append(m.ChangesetId, int64(v))
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.ChangesetId = append(m.ChangesetId, int64(v))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangesetId", wireType)
			}
		case 4:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.UserId = append(m.UserId, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.UserId = append(m.UserId, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
		case 5:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.UserSid = append(m.UserSid, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.UserSid = append(m.UserSid, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserSid", wireType)
			}
		case 6:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Visible = append(m.Visible, bool(v != 0))
				}
			} else if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Visible = append(m.Visible, bool(v != 0))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Way) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Way: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Way: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Keys = append(m.Keys, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Keys = append(m.Keys, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
		case 3:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vals = append(m.Vals, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vals = append(m.Vals, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vals", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &Info{}
			}
			if err := m.Info.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Refs = append(m.Refs, int64(v))
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Refs = append(m.Refs, int64(v))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Relation) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Relation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Relation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Keys = append(m.Keys, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Keys = append(m.Keys, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
		case 3:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vals = append(m.Vals, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vals = append(m.Vals, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vals", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &Info{}
			}
			if err := m.Info.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Roles = append(m.Roles, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Roles = append(m.Roles, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
		case 9:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Refs = append(m.Refs, int64(v))
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Refs = append(m.Refs, int64(v))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
		case 10:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Relation_MemberType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (Relation_MemberType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Types = append(m.Types, v)
				}
			} else if wireType == 0 {
				var v Relation_MemberType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (Relation_MemberType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Types = append(m.Types, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOsm(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOsm
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOsm(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOsm = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOsm   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("osm.proto", fileDescriptorOsm) }

var fileDescriptorOsm = []byte{
	// 755 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x53, 0xc1, 0x4e, 0xe3, 0x48,
	0x10, 0x4d, 0xbb, 0xed, 0xc4, 0xae, 0x00, 0x09, 0x86, 0x40, 0xc3, 0x4a, 0x59, 0x2b, 0xda, 0x83,
	0xa5, 0x15, 0x41, 0xca, 0x1f, 0x90, 0x85, 0x03, 0xd2, 0x02, 0x12, 0x8b, 0x84, 0x76, 0x2f, 0x91,
	0x13, 0x77, 0x82, 0xb5, 0xb6, 0x3b, 0x72, 0x3b, 0x2c, 0xd1, 0xde, 0x38, 0xee, 0x69, 0xe7, 0x36,
	0x3f, 0x31, 0xff, 0xc1, 0x71, 0xce, 0x73, 0x18, 0x8d, 0x98, 0x1f, 0x19, 0x75, 0xd9, 0x8e, 0x0d,
	0x99, 0xc3, 0x1c, 0xb8, 0xd9, 0xef, 0x55, 0x75, 0x55, 0xbd, 0x7a, 0x05, 0x96, 0x90, 0x51, 0x7f,
	0x9e, 0x88, 0x54, 0xd8, 0x54, 0xc8, 0xe8, 0xf0, 0x68, 0x16, 0xa4, 0x77, 0x8b, 0x71, 0x7f, 0x22,
	0xa2, 0xe3, 0x99, 0x98, 0x89, 0x63, 0xe4, 0xc6, 0x8b, 0x29, 0xfe, 0xe1, 0x0f, 0x7e, 0x65, 0x39,
	0xbd, 0x47, 0x0d, 0xac, 0xdf, 0xee, 0xbc, 0x78, 0xc6, 0x25, 0x4f, 0xed, 0x36, 0x68, 0x81, 0xcf,
	0x88, 0x43, 0x5c, 0x3a, 0xd4, 0x9f, 0x3e, 0xff, 0x4c, 0xec, 0x36, 0xe8, 0x7f, 0xf3, 0xa5, 0x64,
	0x9a, 0x43, 0xdd, 0xcd, 0xa1, 0xd6, 0x46, 0xe4, 0xde, 0x0b, 0x25, 0xa3, 0x2b, 0xa4, 0x03, 0x8d,
	0x85, 0xe4, 0xc9, 0x28, 0xf0, 0x99, 0xe1, 0x10, 0xd7, 0xc8, 0x53, 0xf7, 0xc0, 0x44, 0x58, 0x06,
	0x3e, 0xab, 0x3b, 0xc4, 0xdd, 0xcc, 0x71, 0x06, 0x30, 0x49, 0xb8, 0x97, 0x72, 0x7f, 0xe4, 0xa5,
	0xac, 0x51, 0x29, 0xb6, 0x0f, 0xd6, 0x24, 0x14, 0x32, 0x23, 0xcc, 0x0a, 0x61, 0x83, 0x2e, 0xe6,
	0x3c, 0x66, 0x96, 0x43, 0x5c, 0x33, 0xc7, 0x7e, 0x82, 0xfa, 0x58, 0x2c, 0x62, 0x5f, 0x32, 0x70,
	0x88, 0xdb, 0x1c, 0x34, 0xfb, 0x4a, 0x89, 0x21, 0x42, 0x8a, 0x9c, 0xe0, 0x54, 0xac, 0x59, 0x21,
	0xb3, 0x41, 0xed, 0x16, 0x34, 0x64, 0x9a, 0x04, 0xf1, 0x4c, 0xb2, 0x5d, 0x87, 0xba, 0x56, 0xcf,
	0x87, 0x7a, 0x9e, 0xd7, 0x81, 0x46, 0x14, 0xc4, 0xa3, 0x50, 0xc4, 0x8c, 0x38, 0x9a, 0x6b, 0x63,
	0xad, 0x1a, 0xc2, 0xde, 0x03, 0xc2, 0xda, 0x2b, 0x58, 0x45, 0x7b, 0x29, 0xa3, 0xdf, 0x89, 0xf6,
	0x52, 0xa6, 0x97, 0x70, 0xef, 0x91, 0x40, 0x3d, 0xef, 0x80, 0x41, 0x3d, 0x93, 0x00, 0xb5, 0x6e,
	0x0e, 0x4c, 0x6c, 0xef, 0xea, 0x8f, 0x0b, 0xc5, 0x44, 0xc2, 0x0f, 0xa6, 0x4b, 0xa6, 0xad, 0x33,
	0x3e, 0x0f, 0x79, 0xca, 0x19, 0x7d, 0xc5, 0x1c, 0x40, 0x63, 0x22, 0xe2, 0x94, 0x3f, 0xa8, 0x7a,
	0x2f, 0xa9, 0xb5, 0x51, 0x0f, 0x40, 0xbf, 0xf1, 0x66, 0xd2, 0xde, 0x06, 0x4b, 0xed, 0x75, 0x84,
	0xab, 0x24, 0x48, 0x7d, 0x20, 0x40, 0x55, 0x4e, 0x29, 0x2c, 0x59, 0x17, 0x96, 0x81, 0x11, 0x0b,
	0x9f, 0x67, 0x86, 0x68, 0x0e, 0x2c, 0xe4, 0x2e, 0x85, 0xcf, 0xed, 0x5f, 0xa0, 0xe9, 0xf3, 0x58,
	0xf2, 0x51, 0xc6, 0x67, 0x4d, 0xb6, 0x90, 0x3f, 0x55, 0xb8, 0x0a, 0x92, 0xf6, 0x1e, 0xe8, 0xff,
	0x78, 0x4b, 0xc9, 0x74, 0x4c, 0xcf, 0x1a, 0xbd, 0xf5, 0x96, 0xb6, 0x03, 0x56, 0xc2, 0x43, 0x2f,
	0x0d, 0x44, 0x2c, 0x99, 0x81, 0xe4, 0x26, 0x92, 0xd7, 0x39, 0x5a, 0x1d, 0xa5, 0x85, 0xfd, 0xfe,
	0x0b, 0x3a, 0x16, 0x2e, 0x4c, 0xab, 0xe5, 0x76, 0xa9, 0xfd, 0x90, 0x69, 0xf7, 0x41, 0x0f, 0xe2,
	0xa9, 0xc8, 0x15, 0xcb, 0xe6, 0x38, 0x8f, 0xa7, 0xc2, 0xde, 0x06, 0x1a, 0xa2, 0xfd, 0xca, 0x85,
	0x2a, 0x48, 0x28, 0xf7, 0x95, 0xcb, 0x7c, 0x4f, 0x40, 0xc7, 0xf0, 0x0e, 0x34, 0xee, 0x79, 0x22,
	0x03, 0x74, 0x4c, 0x61, 0xfe, 0x9a, 0xb2, 0x72, 0x1a, 0x44, 0x5c, 0xa6, 0x5e, 0x34, 0xc7, 0x55,
	0x16, 0xbd, 0x1d, 0xc2, 0xc6, 0xa4, 0xb8, 0x37, 0x75, 0x31, 0xb4, 0xc2, 0x55, 0x0e, 0x49, 0xaf,
	0xbc, 0x55, 0x3d, 0x24, 0x63, 0x75, 0x48, 0x18, 0x7e, 0x1f, 0xc8, 0x60, 0x1c, 0x72, 0xbc, 0xaf,
	0xfc, 0x30, 0x7a, 0xff, 0x11, 0x80, 0x8a, 0xe2, 0x5b, 0xb9, 0x3c, 0xd4, 0xb5, 0x71, 0xf0, 0x1e,
	0x40, 0xb6, 0x27, 0x1c, 0xdf, 0xc0, 0xf1, 0xb7, 0xca, 0x35, 0xe1, 0x50, 0xad, 0x42, 0x83, 0x22,
	0xa9, 0x55, 0x28, 0x50, 0x00, 0x9d, 0xaa, 0x7f, 0x60, 0xa5, 0xea, 0xda, 0x92, 0xde, 0x11, 0xb0,
	0xca, 0x77, 0x77, 0xaa, 0x62, 0x51, 0xd7, 0x28, 0x9e, 0xaa, 0x4a, 0x55, 0x54, 0x60, 0x6b, 0x42,
	0x15, 0xcc, 0x4e, 0x55, 0x26, 0xea, 0x6e, 0x23, 0xb8, 0xfb, 0x42, 0xa4, 0x02, 0xdd, 0xa9, 0x4a,
	0x44, 0x5d, 0x53, 0x81, 0xbd, 0x29, 0x50, 0x65, 0xb9, 0x37, 0xf6, 0x4d, 0x1b, 0xf4, 0x84, 0x4f,
	0x65, 0x29, 0x5a, 0xef, 0x13, 0x01, 0x73, 0x65, 0xdf, 0x37, 0x77, 0xa9, 0x91, 0x88, 0x90, 0x67,
	0xe5, 0x56, 0xd9, 0xd8, 0x40, 0xb9, 0xa4, 0x5f, 0xc1, 0x48, 0x97, 0x73, 0x9e, 0x2d, 0x68, 0x6b,
	0xc0, 0x5e, 0x1c, 0x54, 0xff, 0x82, 0x47, 0x63, 0x9e, 0xdc, 0x2c, 0xe7, 0x1c, 0xbb, 0x3d, 0x02,
	0x28, 0x11, 0xdb, 0x04, 0xfd, 0xf2, 0xea, 0xf4, 0xac, 0x5d, 0xb3, 0x1b, 0x40, 0x6f, 0x4f, 0xfe,
	0x6c, 0x13, 0x7b, 0x03, 0xcc, 0xeb, 0xb3, 0xdf, 0x4f, 0x6e, 0xce, 0xaf, 0x2e, 0xdb, 0xda, 0x70,
	0xff, 0xe9, 0xb9, 0x4b, 0x3e, 0x3e, 0x77, 0xc9, 0x97, 0xe7, 0x2e, 0xf9, 0xff, 0x6b, 0xb7, 0xf6,
	0x97, 0x21, 0x64, 0x34, 0x1f, 0x7f, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x05, 0x1f, 0x13, 0xb2, 0x91,
	0x06, 0x00, 0x00,
}
